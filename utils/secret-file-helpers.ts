/**
 * Secret File Helpers
 *
 * Utilities for managing secret files including format conversion,
 * .gitignore management, and shell RC file integration
 */

import fs from 'fs'
import path from 'path'
import { expandTilde } from './path-helpers'

/**
 * Parse .env format (KEY=value) and convert to shell exports
 */
export function parseEnvToShellExports(envContent: string): string[] {
  const lines = envContent.split('\n')
  const exports: string[] = []

  for (const line of lines) {
    const trimmed = line.trim()

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    // Match KEY=value or KEY="value" pattern (without export prefix)
    const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)\s*=\s*(.+)$/)
    if (match) {
      const [, key, value] = match
      // Check if value is already quoted
      const isQuoted = (value.startsWith('"') && value.endsWith('"')) ||
                       (value.startsWith("'") && value.endsWith("'"))

      if (isQuoted) {
        exports.push(`export ${key}=${value}`)
      } else {
        // Add quotes if not present
        exports.push(`export ${key}="${value}"`)
      }
    }
  }

  return exports
}

/**
 * Recursively flatten JSON object and convert to shell exports
 * Only processes string values, skips nested objects/arrays
 */
export function parseJsonToShellExports(jsonContent: string): string[] {
  const exports: string[] = []

  try {
    const data = JSON.parse(jsonContent)

    function processObject(obj: any, prefix: string = ''): void {
      for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}_${key}` : key

        if (typeof value === 'string') {
          // Convert to uppercase with underscores
          const envKey = fullKey.toUpperCase().replace(/[^A-Z0-9]/g, '_')
          // Escape double quotes in value
          const escapedValue = value.replace(/"/g, '\\"')
          exports.push(`export ${envKey}="${escapedValue}"`)
        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          // Recursively process nested objects
          processObject(value, fullKey)
        }
        // Skip arrays and non-string primitive values
      }
    }

    processObject(data)
  } catch (error) {
    throw new Error(`Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }

  return exports
}

/**
 * Create or update a .env.sh file with the given export statements
 */
export function createOrUpdateEnvShFile(filePath: string, exports: string[], append: boolean = false): void {
  const expandedPath = expandTilde(filePath)

  const header = `# Secret environment variables
# This file contains sensitive data and should NOT be committed to version control
# Generated by Dotport

`

  const content = header + exports.join('\n') + '\n'

  if (append && fs.existsSync(expandedPath)) {
    // Append to existing file
    fs.appendFileSync(expandedPath, '\n' + exports.join('\n') + '\n', 'utf-8')
  } else {
    // Create new file or overwrite
    fs.writeFileSync(expandedPath, content, 'utf-8')
  }
}

/**
 * Check if a file path is already in .gitignore
 */
export function isInGitignore(gitignorePath: string, filePattern: string): boolean {
  try {
    const expandedPath = expandTilde(gitignorePath)

    if (!fs.existsSync(expandedPath)) {
      return false
    }

    const content = fs.readFileSync(expandedPath, 'utf-8')
    const lines = content.split('\n').map(l => l.trim())

    // Check if the exact pattern exists (ignoring comments and empty lines)
    return lines.some(line =>
      line === filePattern &&
      !line.startsWith('#') &&
      line.length > 0
    )
  } catch (error) {
    return false
  }
}

/**
 * Add file patterns to .gitignore (creates file if it doesn't exist)
 */
export function addToGitignore(gitignorePath: string, patterns: string | string[]): void {
  const expandedPath = expandTilde(gitignorePath)
  const patternsArray = Array.isArray(patterns) ? patterns : [patterns]

  // Filter out patterns that are already in .gitignore
  const newPatterns = patternsArray.filter(pattern => !isInGitignore(gitignorePath, pattern))

  if (newPatterns.length === 0) {
    return // All patterns already exist
  }

  const header = '# Secret files (added by Dotport)\n'
  const content = newPatterns.join('\n') + '\n'

  if (fs.existsSync(expandedPath)) {
    // Check if file ends with newline
    const existingContent = fs.readFileSync(expandedPath, 'utf-8')
    const needsNewline = existingContent.length > 0 && !existingContent.endsWith('\n')

    fs.appendFileSync(
      expandedPath,
      (needsNewline ? '\n' : '') + '\n' + header + content,
      'utf-8'
    )
  } else {
    // Create new .gitignore
    fs.writeFileSync(expandedPath, header + content, 'utf-8')
  }
}

/**
 * Check if a shell RC file sources a secret file
 */
export function isSourcedInRcFile(rcFilePath: string, secretFilePath: string): boolean {
  try {
    const expandedRcPath = expandTilde(rcFilePath)

    if (!fs.existsSync(expandedRcPath)) {
      return false
    }

    const content = fs.readFileSync(expandedRcPath, 'utf-8')
    const lines = content.split('\n')

    // Match patterns like:
    // source ~/.env.sh
    // . ~/.env.sh
    // [ -f ~/.env.sh ] && source ~/.env.sh
    // [[ -f ~/.env.sh ]] && source ~/.env.sh
    const sourcePattern = new RegExp(
      `(source|\\.)\\s+${secretFilePath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`,
      'i'
    )

    return lines.some(line => {
      const trimmed = line.trim()
      return !trimmed.startsWith('#') && sourcePattern.test(trimmed)
    })
  } catch (error) {
    return false
  }
}

/**
 * Add source statement to shell RC file
 */
export function addSourceToRcFile(rcFilePath: string, secretFilePath: string): void {
  const expandedRcPath = expandTilde(rcFilePath)

  if (!fs.existsSync(expandedRcPath)) {
    throw new Error(`RC file not found: ${rcFilePath}`)
  }

  const sourceStatement = `
# Load secret environment variables (added by Dotport)
[ -f ${secretFilePath} ] && source ${secretFilePath}
`

  fs.appendFileSync(expandedRcPath, sourceStatement, 'utf-8')
}

/**
 * Get the appropriate RC file path based on shell type
 */
export function getRcFilePath(shell: 'bash' | 'zsh' | 'fish' | 'other'): string {
  switch (shell) {
    case 'zsh':
      return '~/.zshrc'
    case 'bash':
      return '~/.bashrc'
    case 'fish':
      return '~/.config/fish/config.fish'
    default:
      return '~/.profile'
  }
}
